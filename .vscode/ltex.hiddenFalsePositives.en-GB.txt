{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qholda = hls_test_func_a(h, n/2); holdb = hls_test_func_b(h, (n/2 - 1));\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\Qholda = hls_test_func_a(h, n/2); holdb = hls_test_func_b(h, (n/2 - 1)); holda = hls_test_func_a(h, n/2); holdb = hls_test_func_b(h, (n/2 - 1));\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qholda = hls_test_func_a(h, n/2); holdb = hls_test_func_b(h, (n/2 - 1)); holda = hls_test_func_a(h, n/2); holdb = hls_test_func_b(h, (n/2 - 1));\\E$"}
{"rule":"WORD_CONTAINS_UNDERSCORE","sentence":"^\\QNote: The first function in a “split_fpga”\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qsplit_fpga holda = <0>hls_test_func_a(h, n); holdb = <1>hls_test_func_b(h, n); holdc = <2>hls_test_func_c(h, n); holdd = <3>hls_test_func_d(h, n); Method of allowing user to dictate which child FPGA a function is called on\\E$"}
{"rule":"WHETHER","sentence":"^\\QWhen allowing for systems with 3+ FPGAs a decision has to be made as to whether the user should decide which off-chip functions go on which child FPGA.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\Qsplit_FPGA holda = <0>hls_test_func_a(h, n); holdb = <1>hls_test_func_b(h, n); holdc = <2>hls_test_func_c(h, n); holdd = <3>hls_test_func_d(h, n); Method of allowing user to dictate which child FPGA a function is called on\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\Qsplit_fpga holda = <0>hls_test_func_a(h, n); holdb = <1>hls_test_func_b(h, n); holdc = <2>hls_test_func_c(h, n); holdd = <3>hls_test_func_d(h, n); Method of allowing user to dictate which child FPGA a function is called on\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qfor(i = 0; i < 20; i = i + 1) // Some code \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q assignment1: begin state <= forCondExpr2; end forCondExpr2: begin state <= forBranch3; end forBranch3: begin state <= forCond1 ?\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qx = func(3, 5); \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q func func0( .clk(clk), .clk_en(clk_en), .reset(reset), .a(a0), .b(b0), .start(func_start0), .done(func_done0), .d_out(func_out0) ); Module Instantiation: Function Call converted by SystemNaim\\E$"}
{"rule":"EN_QUOTES","sentence":"^\\QIn \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, we can see that when the program is in this state, the program will either stay in the loop, and go to the first state generated by the code within the loop, or exit the loop which results in the FSM jumping to state generated just after the “for loop\".\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_RULE","sentence":"^\\QSPI Clock (Hz) Channel Latency Latency (Cycles) Overhead (Cycles) Transfer Overhead Interconnect Overhead 125,000 400 52,918 52,794 51,200 1,594 250,000 200 26,518 26,394 25,600 794 252,525* 198 26,254 26,130 25,344 786 277,777* 180 23,878 23,754 23,040 714 312,500 160 26,532 26,408 20,480 5,928 347,222* 144 23,892 23,768 18,432 5,336 500,000 100 16,632 16,508 12,800 3,708 1,000,000 50 8,382 8,258 6,400 1,858 1,923,076* 26 4,422 4,298 3,328 970 5,000,000 10 1,782 1,558 1,280 278 8,333,333* 6 1,122 998 768 230 12,500,000 4 792 668 512 156 25,000,000 2 542 418 256 162 [*] These values for SPI clock speed are not factors of the system clock, and are actually irrational.\\E$"}
{"rule":"ADVERB_VERB_ADVERB_REPETITION","sentence":"^\\QSPI Clock (Hz) Channel Latency Latency (Cycles) Overhead (Cycles) Transfer Overhead Interconnect Overhead 125,000 400 52,918 52,794 51,200 1,594 250,000 200 26,518 26,394 25,600 794 252,525* 198 26,254 26,130 25,344 786 277,777* 180 23,878 23,754 23,040 714 312,500 160 26,532 26,408 20,480 5,928 347,222* 144 23,892 23,768 18,432 5,336 500,000 100 16,632 16,508 12,800 3,708 1,000,000 50 8,382 8,258 6,400 1,858 1,923,076* 26 4,422 4,298 3,328 970 5,000,000 10 1,782 1,558 1,280 278 8,333,333* 6 1,122 998 768 230 12,500,000 4 792 668 512 156 25,000,000 2 542 418 256 162 [*] These values for SPI clock speed are not factors of the system clock, and are actually irrational.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QIn order to illustrate the usability of the tool we will go through a design example, where we create a multi-FPGA system in SystemNaim, and then perform a qualitative comparison to creating a similar system but purely in Quartus II using only SystemVerilog and the IP catalog.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QIn order to do so, they need to click “New...” in the IP Catalog, which results in another window being opened: the Component Editor.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QNow that their module has been added to the catalog, a user can search for their custom hardware and add it to their system.\\E$"}
{"rule":"OUTSIDE_OF","sentence":"^\\QThis means that not only does it enable SystemNaim to generate multi-FPGA systems that work with multiple communication protocols, but also allows for the interconnect to be used outside of SystemNaim by those who want to implement their own multi-FPGA systems using something similar to an RPC model.\\E$"}
