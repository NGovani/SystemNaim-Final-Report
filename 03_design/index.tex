\chapter{SystemNaim: Design Goals}

Since SystemNaim is a tool with many parts needing to be implemented, each aspect of the tool had different motivations and goals. For some parts we focused on getting a working product and for others we focused on optimality so that the end result was a tool which allowed to perform a full investigation of our aims. The following sections will go through the goals for each major segment of SystemNaim and discuss what we hoped that segment would contribute to the final tool.

\section{HLS}

The HLS aspect of SystemNaim is its backbone, it's what allows us to give more people access to multi-FPGA systems, and thus it's focus had to be on usability. ANSI C90 was our input language of choice, due to both its simplicity and widespread knowledge of its syntax. Anyone who understands the basic concepts of programming: variables, loops and functions, would be able to pick C90 in less than a few minutes. Its simple grammar also means the HLS tool also becomes much simpler. This is important because while the HLS tool is integral to SystemNaim it is also an aspect which could take up the entire development time if not limited in scope. 

Creating a competitive HLS tool would take years, but we didn't need a tool which rivalled Vivado HLS or LegUp, instead we just needed something that would allow us to prove we could automate the creation of a multi-FPGA system. Therefore, the HLS aspect of SystemNaim did not need to implement any hardware optimizations or even the full C90 feature set, it just needed to create functional hardware.

While optimizations were not a major concern, usability was. It needed to be easy for a user to designate which parts of the system they wanted to run on and off-chip, and it was therefore decided to use functions as a way of giving users control of hardware placement. The concept of a function is taught to every software engineer, it's a method of dividing the code base into smaller understandable chunks as well as avoiding code re-use, and in many ways share's similarities to hardware modules. Therefore, making the user decide where parts of the program would be run through the use of functions, is both intuitive for the user and simpler to implement for the tool.

In summary, the HLS tool needed to have a low learning curve, so that it wasn't overly complicated to new users, while still being able to generate a wide variety of hardware system so that we perform a full investigation.

\section{Inter-connect}

The interconnect acts as the interface between the communication channel and the hardware generated by the HLS. It takes data from the HLS and passes it to the child FPGAs so that they can begin their processing. Without the interconnect, the HLS would have to directly control the channel which would require complex HDL to be generated every time the tool was run. By, instead, designing custom hardware, with a simple interface, the HLS can communicate with the interconnect thus resulting in simpler hardware being generated.

In essence, the interconnect forms a layer of abstraction between the HLS and the communication channel, so that the HLS tool does not require knowledge on how to control the channel in order to use it, thus lending towards the interconnect being modular in nature, which was one of the main goals we had when designing the hardware. We wanted the interconnect to act a form of abstraction in both directions; the HLS should have no knowledge of the channel, as mentioned, and the channel should have no knowledge of the HLS tool. With the intended result being that the interconnect could be used with any combination of HLS tool and communication channel.

This was done because the interconnect is the most important part of this project. Its design decides how each FPGA communicates with each other, what the extra latency of the system is, what limitations are there for the off-chip processing? Therefore, it seemed like a waste to design custom hardware which could only be used in a single system. Instead, if we created a specification which could interface with multiple communication channels and had the potential to work with multiple HLS tools, we would have made something that could be used in other projects and could act as inspiration for future multi-FPGA system.

\section{Communication Channel}

\begin{itemize}
    \item This section would talk about the benefits of different communication channels. SPI, Ethernet and PCIE would be discussed.
    \item Maybe talk about how each of these channels usually have a pre-built core that this project will use and that the main design challenge is creating hardware which can interface with the core.
\end{itemize}

The communication channel was the area of SystemNaim we had the least control over, it would have been to large an undertaking to create our own protocol, and thus we had to choose from a set of pre-existing ones. What we were looking for was that had a high channel bandwidth but low protocol complexity. By protocol complexity, we mean how many additional bits are sent over the channel besides the actual payload that we are trying to transmit.

The higher the protocol complexity the more bits are being sent on every transaction and thus make each one take longer. Ethernet is a good example of protocol which has a high amount of overhead, but also very fast bandwidth. Each transaction may have had 50 bytes of overhead data, which ends up increasing the latency of the resulting system, however, Ethernet can also run at very high bandwidths, so this additional overhead can be mitigated when compared to other protocols.

At it's core the communication channel just needs to allow each FPGA to send and receive data, therefore it didn't matter too much about which one we chose. In addition, with the interconnect being designed in a such a way where the channel protocol could be changed later on without requiring total overhauls of SystemNaim, we were able to pick the protocol that was the easiest to implement. The channel protocol could then, in the future, be chosen according to a user's bandwidth needs and port availability.

